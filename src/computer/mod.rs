use crate::computer::cpu::CPU;
use crate::computer::memory::Memory;

mod cpu;
mod memory;

/// Тип определяющий разрядность нашей архитектуры.
type ArcBitDepth = u16;

/// Тип определяющий разрядность шины адреса.
type AddrBitDepth = u16;

/// Константа, определяющая адрес начала программы в памяти. Константа инициализирует
/// стартовую позицию регистра счетчика команд.
const PC_START: AddrBitDepth = 0x3000;
const MAX_ADD_BIT_DEPTH: AddrBitDepth = u16::MAX;

pub struct Machine {
    // Компьютер состоит из процессора, памяти.
    memory: Memory,
    cpu: CPU,
}

impl Machine {
    //! Конструктор.
    pub fn new(program: Vec<ArcBitDepth>) -> Machine {

        // Память принадлежит
        let mut memory = Memory::new();
        let mut cpu = CPU::new();

        Machine {
            memory,
            cpu
        }
    }

    /// Один тактовый импульс.
    pub fn tick(&mut self) {
        // Процессор должен реализовывать следующий интерфейс:
        // Метод memory_request() определяющий что именно хочет сделать процессор, считать память или записать или ничего не делать. На каждом tick мы должны опросить процессор.
        // Здесь проявляется интересная особенность: в реальных схемах процессор управляет компьютером, и
        // уровень читать или писать переводит машину в необходимое состояние. Здесь же мы отходим от этого,
        // и рассматриваем процессор как зависимое звено машины, машина спрашивает у процессора что ей делать.
        // Метод address() - получает адрес в памяти, с которого нужно или считать информацию или записать информацию по этому адресу.
        // Методы get_data() и set_data() считывающие информацию от процессора.
        // Так мы сможем использовать различные "процессоры" в нашем компьютере.

    }
}